---
output: 
  github_document:
    toc: TRUE
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = T,
  message = F,
  warning = F,
    out.width = "100%",
    dpi = 300,
    fig.width = 8,
    fig.height = 6
)
```

# ggswitzerland

What follows is inspired and uses much of the code in Timo Grossenbacher and Angelo Zehr's '[Bivariate maps with ggplot2 and sf](https://timogrossenbacher.ch/bivariate-maps-with-ggplot2-and-sf/)'. The source for the blog post is available in the [repo](https://github.com/grssnbchr/bivariate-maps-ggplot2-sf?tab=readme-ov-file).  

One of the plots, which is not actually a bivariate color plot so central to the post, is the target for a replication, and will informs what a minimal ggswitzerland might need in terms of functionality. 

![](https://timogrossenbacher.ch/content/images/size/w1000/2023/07/bm-thematic-univariate-map-1.png)

{ggswitzerland}'s `geom_*()`, `stamp_*()`, and `theme_*()` functions will allow us to *not only* 'write down' this plot in more succinctly, but arguably also in a way that better matches how we think about how to construct the map. 

Specifically, we can use data that has geographic information, *but no boundary information*, to construct our plot.  If we have a dataset with municipality names and income level, for example, we can specify it as follows:

```{r, eval = F}
flat_income_data |> # data frame with 
  ggplot() +
  aes(muni_name = municipality,
      fill = income_levels) + 
  geom_muni()     # knows municipality boundaries
```

Creating functions like `geom_muni()` can be done easily using the {ggregions} package.  In the background, `geom_muni()` performs a join with geo-referenced data so that the flat data can be represented on the map.

Annotation layers `stamp_relief()` (and alias `stamp_mountains()`) as well as `stamp_lake()` and `stamp_canton()` are also specified to allow the map to be fully reproduced.

For ease and consistency, geom_ and stamp_ functions are created with 'utilities' from the *ggregions* package.

# Let's go! Building {ggswitzerland}

Now it's time to craft some functions!

## `theme_map()`

This is pretty much verbatim from Timo and Angelo's blog, but *does* add palette definitions, a capability new in ggplot2 4.0.0. We use 'magma' since it looks great in the target plot and is colorblind friendly!

```{r theme_map, echo=TRUE, message=FALSE, warning=FALSE}
#' @export
theme_map <- function(...) {
  theme_minimal() +
  theme(
    palette.fill.continuous = "magma",
    palette.fill.discrete = "magma",
    palette.fill.binned = "magma",
    palette.color.continuous = "magma",
    palette.color.discrete = "magma",
    palette.color.binned = "magma",
    text = element_text(color = "#4e4d47"),
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    panel.grid.major = element_line(color = "#dbdbd9", size = 0.2),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "#f5f5f2",
                                   color = NA),
    panel.background = element_rect(fill = "#f5f5f2",
                                    color = NA),
    legend.background = element_rect(fill = "#f5f5f2",
                                     color = NA),
    plot.margin = unit(c(.5, .5, .2, .5), "cm"),
    panel.border = element_blank(),
    panel.spacing = unit(c(-.1, 0.2, .2, 0.2), "cm"),
    legend.title = element_text(size = 11),
    legend.text = element_text(size = 9, hjust = 0,
                               color = "#4e4d47"),
    plot.title = element_text(size = 15, hjust = 0.5,
                              color = "#4e4d47"),
    plot.subtitle = element_text(size = 10, hjust = 0.5,
                                 color = "#4e4d47",
                                 margin = margin(b = -0.1,
                                                 t = -0.1,
                                                 l = 2,
                                                 unit = "cm"),
                                 debug = F),
    plot.caption = element_text(size = 7,
                                hjust = .5,
                                margin = margin(t = 0.2,
                                                b = 0,
                                                unit = "cm"),
                                color = "#939184"),
    ...
  )
}
```


## data prep

Here's some info about the data provinance, verbatim from the blog. 

> Various geodata from the Swiss Federal Statistical Office (FSO) and the Swiss Federal Office of Topography (swisstopo) depicting Swiss borders as of 2015 are used herein.

> * `input/gde-1-1-15.*`: These geometries do not show the political borders of Swiss municipalities, but the so-called "productive" area, i.e., larger lakes and other "unproductive" areas such as mountains are excluded. This has two advantages: 1) The relatively sparsely populated but very large municipalities in the Alps don't have too much visual weight and 2) it allows us to use the beautiful raster relief of the Alps as a background. These data are now freely available [from the FSO](https://www.bfs.admin.ch/bfs/en/home/statistics/regional-statistics/base-maps/cartographic-bases.assetdetail.7546178.html). Click on "Download map (ZIP)", the polygon files are in `/PRO/01_INST/Vegetationsfläche_vf/K4_polgYYYYMMDD_vf`; different timestamps are available, the 2015 data used here stem from another data set.
> * `input/g2*`: National (`s`) as well as cantonal borders (`k`) and lakes (`l`). Available [here](https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html).


Now we prep the data prep in a way that is appropriate for the ggregions methodology.  We keep the name of the region as the 1st column, and any other region-identifying column of data that we might want to use, e.g. `aes(canton_num = my_canton_num_id_var)`.  Critically geometry columns are preserved for drawing the regions.  Note that `dplyr::select()` does not remove geometry even when the variable is not explicitly referenced.

```{r data_prep}
library(tidyverse)
# read cantonal borders
canton_geo <- read_sf("input/g2k15.shp") |>
  dplyr::select(canton_name = KTNAME, canton_num = KTNR)

# read country borders
country_geo <- read_sf("input/g2l15.shp") |> 
  dplyr::select(iso_chr = CH_ISO)

# read lakes
lake_geo <- read_sf("input/g2s15.shp") |>
  dplyr::select(lake_name = GMDNAME, lake_num = GMDNR)

# read productive area (2324 municipalities)
muni_prod_geo <- read_sf("input/gde-1-1-15.shp") |> 
  dplyr::select(muni_name = Secondary_, muni_id = BFS_ID, geometry)
```

### Mountain data

Drawing the mountain data is not an sf object, and is a little different.  First a bit on the source from the blog:

> * (Hillshaded) relief: This is a freely available GeoTIFF from [swisstopo](https://shop.swisstopo.admin.ch/en/products/maps/national/digital/srm1000). For the sake of simplicity, it was converted to the "ESRI ASCII" format using ` gdal_translate -of AAIGrid 02-relief-georef.tif 02-relief-ascii.asc` on the CLI. The `raster` can read that format natively, without the need of explicitly installing the `rgdal` package – which is not the case for GeoTIFF files.


```{r}
library(raster)
# read in raster of relief
relief <- raster("input/02-relief-ascii.asc") %>%
  # hide relief outside of Switzerland by masking with country borders
  mask(country_geo) %>%
  as("SpatialPixelsDataFrame") %>%
  as.data.frame() %>%
  dplyr::rename(value = `X02.relief.ascii`) |> 
  mutate(value_01 = (value - min(value))) |>
  mutate(value_01 = value_01/max(value_01)) |>
  mutate(value_point6_0 = value_01 * .6) |>
  mutate(value_point6_0 = 1 - value_point6_0 - .4)
```

### we need to include each of our prepared datasets in the package

```{r}
usethis::use_data(relief, overwrite = T)
usethis::use_data(canton_geo, overwrite = T)
usethis::use_data(country_geo, overwrite = T)
usethis::use_data(lake_geo, overwrite = T)
usethis::use_data(muni_prod_geo, overwrite = T)
```

## `geom_*()` and `stamp_*()` functions using `ggregions::write_*(ref_data = ?)`

Install {ggregions} if you don't already have the package.

```{r, eval = F}
remotes::install_github("EvaMaeRey/ggregions")
```

Now we can prepare the geographic layer functions...

```{r geom_regions_functions}
#' @export
geom_muni <- ggregions::write_geom_region_locale(ref_data = muni_prod_geo)

#' @export
stamp_canton <- ggregions::write_stamp_region_locale(canton_geo)

#' @export
stamp_lake <- ggregions::write_stamp_region_locale(lake_geo)
```


## `stamp_mountains()`

Mountains have a bit different character, so we look at this separately.


```{r stamp_mountains}
#' @export
stamp_relief <- function(...){ 
  
  annotate(geom = "raster",
      x = relief$x,
      y = relief$y,
      alpha = relief$value_point6_0,
    ...)
  
}

# I think there is something to be said for both names
#' @export
stamp_mountains <- stamp_relief
```



# packaging


### code management 

We send our code to the .R folder for this package with `knitrExtra::chunk_to_dir()`

```{r}
knitrExtra::chunk_to_dir(
  c("stamp_mountains", 
    "geom_regions_functions",
    "theme_map")
  )
```

### Document, check, install minimal package

```{r, eval = F}
devtools::document(".")
devtools::check(".")
devtools::install(".", upgrade = "never")
```

# Use ggswitzerland! A replication of Timo and Angelo's mapping work (some data preparation that is demo-ed in the blog is saved in the csv.)

## Basic Vizzing

### data to viz

```{r}
muni_income_data <- 
  read_csv("input/muni_income_data.csv") 

# check that it's a flat file
# i.e. geo references, but no boundary info
head(muni_income_data)
```

### viz itself

```{r}
library(tidyverse)
library(ggswitzerland)
theme_map() |> theme_set()

muni_income_data |>
  ggplot() + 
  stamp_mountains() + 
  aes(muni_name = municipality) +
  geom_muni() + 
  aes(fill = mean_quantiles) +
  stamp_canton(fill = "transparent") + 
  stamp_lake(fill = "#D6F1FF")
```

## A little more styling and labels.

```{r}
default_caption <- paste0("Map CC-BY-SA; Code: ",
                          "github.com/grssnbchr/bivariate-maps-ggplot2-sf",
                          "\nAuthors: Timo Grossenbacher",
                          " (@grssnbchr), Angelo Zehr (@angelozehr)",
                          "\nGeometries: ThemaKart BFS and swisstopo;",
                          " Data: ESTV, 2015")


```

```{r}
muni_income_data |> 
  ggplot() + 
  stamp_mountains() + 
  aes(muni_name = municipality) +
  geom_muni(alpha = .8, color = "lightgrey") +
  aes(fill = mean_quantiles) +
  stamp_canton(fill = "transparent", 
               color = "whitesmoke", 
               linewidth = .5) + 
  stamp_lake(fill = "#D6F1FF", color = "transparent") + 
  theme_map() + 
  scale_fill_viridis_d(begin = .1, end = .9,
                       option = "magma") +
  labs(x = NULL,  y = NULL,
       fill = "Average\nincome in CHF",
       title = "Switzerland's regional income",
       subtitle = "Average yearly income in Swiss municipalities, 2015",
       caption = default_caption
       ) 
```


Original:

![](https://timogrossenbacher.ch/content/images/size/w1000/2023/07/bm-thematic-univariate-map-1.png)

---

# Bonus: {ggswitzerland} X {ggincerta}

```{r, eval = T}
library(ggincerta) # for duo and scale_*_bivariate

muni_income_data |> 
  ggplot() + 
  stamp_mountains() + 
  aes(muni_name = municipality) +
  geom_muni() + 
  aes(fill = duo(gini, mean))

last_plot() + 
  scale_fill_bivariate(colors = c("darkred", "navy"))
```


Original:

![](https://timogrossenbacher.ch/content/images/size/w1000/2023/07/bm-thematic-bivariate-map-with-legend-1.png)
