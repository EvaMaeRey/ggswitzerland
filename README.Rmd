---
output: 
  github_document:
    toc: TRUE
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = T
)
```



```{r preparations, echo=FALSE, message=FALSE, warning=FALSE}
# define options for saving plots
knitr::opts_chunk$set(
    out.width = "100%",
    dpi = 300,
    fig.width = 8,
    fig.height = 6)


```





```{r read data, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)

``` 



```{r read in geodata, echo=TRUE, message=FALSE, warning=FALSE}
library(sf)

```


# ggswitzerland

## `theme_map()`

```{r theme_map, echo=TRUE, message=FALSE, warning=FALSE}
theme_map <- function(...) {
  theme_minimal() +
  theme(
    palette.fill.continuous = "magma",
    palette.fill.discrete = "magma",
    palette.fill.binned = "magma",
    palette.color.continuous = "magma",
    palette.color.discrete = "magma",
    palette.color.binned = "magma",
    text = element_text(color = "#4e4d47"),
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    panel.grid.major = element_line(color = "#dbdbd9", size = 0.2),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "#f5f5f2",
                                   color = NA),
    panel.background = element_rect(fill = "#f5f5f2",
                                    color = NA),
    legend.background = element_rect(fill = "#f5f5f2",
                                     color = NA),
    plot.margin = unit(c(.5, .5, .2, .5), "cm"),
    panel.border = element_blank(),
    panel.spacing = unit(c(-.1, 0.2, .2, 0.2), "cm"),
    legend.title = element_text(size = 11),
    legend.text = element_text(size = 9, hjust = 0,
                               color = "#4e4d47"),
    plot.title = element_text(size = 15, hjust = 0.5,
                              color = "#4e4d47"),
    plot.subtitle = element_text(size = 10, hjust = 0.5,
                                 color = "#4e4d47",
                                 margin = margin(b = -0.1,
                                                 t = -0.1,
                                                 l = 2,
                                                 unit = "cm"),
                                 debug = F),
    plot.caption = element_text(size = 7,
                                hjust = .5,
                                margin = margin(t = 0.2,
                                                b = 0,
                                                unit = "cm"),
                                color = "#939184"),
    ...
  )
}
```


## data prep

Various geodata from the Swiss Federal Statistical Office (FSO) and the Swiss Federal Office of Topography (swisstopo) depicting Swiss borders as of 2015 are used herein.

* `input/gde-1-1-15.*`: These geometries do not show the political borders of Swiss municipalities, but the so-called "productive" area, i.e., larger lakes and other "unproductive" areas such as mountains are excluded. This has two advantages: 1) The relatively sparsely populated but very large municipalities in the Alps don't have too much visual weight and 2) it allows us to use the beautiful raster relief of the Alps as a background. These data are now freely available [from the FSO](https://www.bfs.admin.ch/bfs/en/home/statistics/regional-statistics/base-maps/cartographic-bases.assetdetail.7546178.html). Click on "Download map (ZIP)", the polygon files are in `/PRO/01_INST/Vegetationsfläche_vf/K4_polgYYYYMMDD_vf`; different timestamps are available, the 2015 data used here stem from another data set.
* `input/g2*`: National (`s`) as well as cantonal borders (`k`) and lakes (`l`). Available [here](https://www.bfs.admin.ch/bfs/de/home/dienstleistungen/geostat/geodaten-bundesstatistik/administrative-grenzen/generalisierte-gemeindegrenzen.html).
* (Hillshaded) relief: This is a freely available GeoTIFF from [swisstopo](https://shop.swisstopo.admin.ch/en/products/maps/national/digital/srm1000). For the sake of simplicity, it was converted to the "ESRI ASCII" format using ` gdal_translate -of AAIGrid 02-relief-georef.tif 02-relief-ascii.asc` on the CLI. The `raster` can read that format natively, without the need of explicitly installing the `rgdal` package – which is not the case for GeoTIFF files.



```{r data_prep}
library(tidyverse)
# read cantonal borders
canton_geo <- read_sf("input/g2k15.shp") |>
  dplyr::select(canton_name = KTNAME, canton_num = KTNR, geometry)

# read country borders
country_geo <- read_sf("input/g2l15.shp") |> 
  dplyr::select(iso_chr = CH_ISO, geometry)

# read lakes
lake_geo <- read_sf("input/g2s15.shp") |>
  dplyr::select(lake_name = GMDNAME, lake_num = GMDNR, geometry)


# read productive area (2324 municipalities)
muni_prod_geo <- read_sf("input/gde-1-1-15.shp") |> 
  dplyr::select(geometry, muni_name = Secondary_, muni_id = BFS_ID)

library(raster)
# read in raster of relief
relief <- raster("input/02-relief-ascii.asc") %>%
  # hide relief outside of Switzerland by masking with country borders
  mask(country_geo) %>%
  as("SpatialPixelsDataFrame") %>%
  as.data.frame() %>%
  dplyr::rename(value = `X02.relief.ascii`)

relief <- relief |> 
    mutate(value_01 = (value - min(value))) |>
    mutate(value_01 = value_01/max(value_01)) |>
    mutate(value_point6_0 = value_01 * .6) |>
    mutate(value_point6_0 = 1 - value_point6_0 - .4)
```



## `stamp_mountains()`


```{r stamp_mountains}
#' @export
stamp_relief <- function(...){ 
  
  annotate(geom = "raster",
      x = relief$x,
      y = relief$y,
      alpha = relief$value_point6_0,
    ...)
  
}

#' @export
stamp_mountains <- stamp_relief
```



## `geom_*()` and `stamp_*()` functions using `ggregions::write_*(ref_data = ?)`

```{r geom_regions_functions}
#' @export
geom_muni <- ggregions::write_geom_region_locale(ref_data = muni_prod_geo)

#' @export
stamp_canton <- ggregions::write_stamp_region_locale(canton_geo)

#' @export
stamp_lake <- ggregions::write_stamp_region_locale(lake_geo)

```

# Use ggswitzerland functions: a replication



```{r}
data <- readr::read_csv("input/data.csv")

head(data)


```


```{r thematic-univariate-map, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
# define number of classes
no_classes <- 6

# extract quantiles
quantiles <- data %>%
  pull(mean) %>%
  quantile(probs = seq(0, 1, length.out = no_classes + 1)) %>%
  as.vector() # to remove names of quantiles, so idx below is numeric


# here we create custom labels
labels <- imap_chr(quantiles, function(., idx){
  return(paste0(round(quantiles[idx] / 1000, 0),
                             "k",
                             " – ",
                             round(quantiles[idx + 1] / 1000, 0),
                             "k"))
})

# we need to remove the last label 
# because that would be something like "478k - NA"
labels <- labels[1:length(labels) - 1]

data <- data |> 
  mutate(mean_quantiles = 
           cut(mean,
               breaks = quantiles,
               labels = labels,
               include.lowest = T))

data |> head()
```


```{r}
library(tidyverse)
# library(ggswitzerland)

theme_map() |> theme_set()

data |> 
  ggplot() + 
  stamp_mountains() + 
  aes(muni_name = municipality) +
  geom_muni() + 
  aes(fill = mean_quantiles) +
  stamp_canton(fill = "transparent") + 
  stamp_lake(fill = "#D6F1FF")
```


```{r}
default_caption <- paste0("Map CC-BY-SA; Code: ",
                          "github.com/grssnbchr/bivariate-maps-ggplot2-sf",
                          "\nAuthors: Timo Grossenbacher",
                          " (@grssnbchr), Angelo Zehr (@angelozehr)",
                          "\nGeometries: ThemaKart BFS and swisstopo;",
                          " Data: ESTV, 2015")


```

```{r}
data |> 
  ggplot() + 
  stamp_mountains() + 
  aes(muni_name = municipality,
      fill = mean_quantiles) +
  geom_muni(alpha = .8, color = "lightgrey") +
  stamp_canton(fill = "transparent", 
               color = "whitesmoke", 
               linewidth = .5) + 
  stamp_lake(fill = "#D6F1FF", color = "transparent") + 
  theme_map()

last_plot() +
  labs(x = NULL,  y = NULL,
       fill = "Average\nincome in CHF",
       title = "Switzerland's regional income",
       subtitle = "Average yearly income in Swiss municipalities, 2015",
       caption = default_caption
       ) 


```


---

# Bonus: {ggswitzerland} X {ggincerta}

```{r, eval = T}
library(ggincerta) # for duo and scale_*_bivariate

data |> 
  ggplot() + 
  stamp_mountains() + 
  aes(muni_name = municipality) +
  geom_muni() + 
  aes(fill = duo(gini, mean))

last_plot() + 
  scale_fill_bivariate(colors = c("darkred", "navy"))
```


